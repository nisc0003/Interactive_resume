---
interface Props {
  imageUrl?: string;
  alt?: string;
  title?: string;
  subtitle?: string;
}

const {
  imageUrl = "https://picsum.photos/800/1000",
  alt = "Hero image",
  title,
  subtitle,
} = Astro.props;
---

<section
  class="relative w-full min-h-screen flex items-center justify-center bg-bg1 py-20 overflow-hidden"
  x-data="puzzleHero()"
  x-init="init()"
  x-intersect:enter="onEnter()"
  x-intersect:leave="onLeave()"
>
  <div class="relative z-10 text-center text-text-white px-6 max-w-4xl mx-auto">
    {
      title && (
        <h1 class="text-6xl md:text-8xl font-display1 font-bold mb-6 drop-shadow-2xl animate-fade-in-down animate-delay-300">
          {title}
        </h1>
      )
    }
    {
      subtitle && (
        <p class="text-2xl md:text-3xl text-text-white/80 font-sans drop-shadow-lg animate-fade-in-up animate-delay-500 mb-12">
          {subtitle}
        </p>
      )
    }

    <!-- Puzzle Image Container - Portrait aspect ratio for your photo -->
    <div class="relative w-full max-w-sm mx-auto aspect-[4/5] mt-8">
      <!-- Puzzle Grid Container -->
      <div
        class="absolute inset-0 grid grid-cols-5 grid-rows-4 gap-1 puzzle-container"
      >
        <!-- Generate 20 puzzle pieces (5x4 grid) -->
        {
          Array.from({ length: 20 }).map((_, index) => {
            const col = index % 5;
            const row = Math.floor(index / 5);
            const bgX = (col / 4) * 100;
            const bgY = (row / 3) * 100;

            return (
              <div
                class="puzzle-piece relative overflow-hidden rounded-sm shadow-lg opacity-0"
                data-index={index}
                style={`
                background-image: url('${imageUrl}');
                background-position: ${bgX}% ${bgY}%;
                background-size: 500% 400%;
                background-repeat: no-repeat;
              `}
              />
            );
          })
        }
      </div>
    </div>
  </div>
</section>

<script is:inline>
  document.addEventListener("alpine:init", () => {
    Alpine.data("puzzleHero", () => ({
      pieces: [],
      inView: false,
      hasAnimatedIn: false,
      floatingInterval: null,
      scrollInterval: null,
      isScrolling: false,
      scrollTimeout: null,

      init() {
        const puzzlePieces = this.$el.querySelectorAll(".puzzle-piece");

        puzzlePieces.forEach((piece, index) => {
          const direction = Math.floor(Math.random() * 4);
          let startX = 0,
            startY = 0;

          switch (direction) {
            case 0:
              startX = -800;
              startY = (Math.random() - 0.5) * 400;
              break;
            case 1:
              startX = 800;
              startY = (Math.random() - 0.5) * 400;
              break;
            case 2:
              startX = (Math.random() - 0.5) * 400;
              startY = -800;
              break;
            case 3:
              startX = (Math.random() - 0.5) * 400;
              startY = 800;
              break;
          }

          this.pieces.push({
            element: piece,
            offsetX: 0,
            offsetY: 0,
            rotation: 0,
            baseX: 0,
            baseY: 0,
            baseRot: 0,
          });
          piece.style.transform = `translate(${startX}px, ${startY}px) rotate(${(Math.random() - 0.5) * 360}deg)`;
        });

        // Listen for scroll events
        window.addEventListener("scroll", () => this.handleScroll());
      },

      handleScroll() {
        this.isScrolling = true;

        // Clear previous timeout
        if (this.scrollTimeout) {
          clearTimeout(this.scrollTimeout);
        }

        // Set timeout to detect when scrolling stops
        this.scrollTimeout = setTimeout(() => {
          this.isScrolling = false;
          this.returnToBase();
        }, 150);

        if (this.inView) {
          this.flowPieces();
        }
      },

      onEnter() {
        this.inView = true;
        if (!this.hasAnimatedIn) {
          this.hasAnimatedIn = true;
          this.animatePiecesIn();
        }
      },

      onLeave() {
        this.inView = false;
        this.scatterPieces();
      },

      animatePiecesIn() {
        this.pieces.forEach((piece, i) => {
          setTimeout(() => {
            piece.element.style.transition =
              "all 1.2s cubic-bezier(0.34, 1.56, 0.64, 1)";
            piece.element.style.opacity = "1";

            const hoverX = (Math.random() - 0.5) * 3;
            const hoverY = (Math.random() - 0.5) * 3;
            const hoverRot = (Math.random() - 0.5) * 2;

            piece.baseX = hoverX;
            piece.baseY = hoverY;
            piece.baseRot = hoverRot;
            piece.offsetX = hoverX;
            piece.offsetY = hoverY;
            piece.rotation = hoverRot;
            piece.element.style.transform = `translate(${hoverX}px, ${hoverY}px) rotate(${hoverRot}deg)`;
          }, i * 40);
        });

        setTimeout(() => this.startFloating(), 1500);
      },

      flowPieces() {
        this.pieces.forEach((piece) => {
          const flowX = piece.baseX + (Math.random() - 0.5) * 16;
          const flowY = piece.baseY + (Math.random() - 0.5) * 16;
          const flowRot = piece.baseRot + (Math.random() - 0.5) * 8;

          piece.element.style.transition = "transform 0.3s ease-out";
          piece.element.style.transform = `translate(${flowX}px, ${flowY}px) rotate(${flowRot}deg)`;
        });
      },

      returnToBase() {
        this.pieces.forEach((piece) => {
          piece.element.style.transition = "transform 0.6s ease-out";
          piece.element.style.transform = `translate(${piece.baseX}px, ${piece.baseY}px) rotate(${piece.baseRot}deg)`;
        });
      },

      scatterPieces() {
        if (this.floatingInterval) {
          clearInterval(this.floatingInterval);
          this.floatingInterval = null;
        }

        this.pieces.forEach((piece, i) => {
          setTimeout(() => {
            piece.element.style.transition =
              "all 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55)";
            const scatterX = (Math.random() - 0.5) * 150;
            const scatterY = (Math.random() - 0.5) * 150;
            const scatterRot = (Math.random() - 0.5) * 30;
            piece.element.style.transform = `translate(${scatterX}px, ${scatterY}px) rotate(${scatterRot}deg)`;
            piece.element.style.opacity = "0.6";
          }, i * 20);
        });
      },

      startFloating() {
        this.floatingInterval = setInterval(() => {
          if (this.inView && !this.isScrolling) {
            this.pieces.forEach((piece) => {
              piece.offsetX += (Math.random() - 0.5) * 0.8;
              piece.offsetY += (Math.random() - 0.5) * 0.8;
              piece.rotation += (Math.random() - 0.5) * 0.3;

              piece.offsetX = Math.max(
                piece.baseX - 4,
                Math.min(piece.baseX + 4, piece.offsetX),
              );
              piece.offsetY = Math.max(
                piece.baseY - 4,
                Math.min(piece.baseY + 4, piece.offsetY),
              );
              piece.rotation = Math.max(
                piece.baseRot - 3,
                Math.min(piece.baseRot + 3, piece.rotation),
              );

              piece.element.style.transition = "transform 1.5s ease-out";
              piece.element.style.transform = `translate(${piece.offsetX}px, ${piece.offsetY}px) rotate(${piece.rotation}deg)`;
            });
          }
        }, 1500);
      },
    }));
  });
</script>

<style>
  .puzzle-piece {
    background-repeat: no-repeat;
    will-change: transform, opacity;
  }

  .puzzle-container {
    filter: drop-shadow(0 10px 30px rgba(0, 0, 0, 0.5));
  }
</style>
